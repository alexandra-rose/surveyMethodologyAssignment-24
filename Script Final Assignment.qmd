---
title: "Final Assignment"
author: Sofia Villamil
format: html
editor: visual
editor_options: 
  chunk_output_type: inline
---

# Final Assignment

CHALLENGE

The assignment has two primary objectives:

1\. Explaining Cross-Country Differences in Support Levels: This aspect involves analyzing the data to understand why different countries exhibit varying levels of support for transgender individuals obtaining official documents (cq19 in the questionnare). Individual-level indicators need to be complemented with country-level factors such as cultural norms, legal systems, history, economic-related variables, and societal views on LGBTI rights.

2.  Developing a Predictive Model for Other Countries This task involves building a model to predict support for transgender individuals changing civil documents to align with their gender identity. By using factors identified in the first part of the assignment, machine learning techniques will be applied to forecast support levels based on observed trends. To ensure the model’s accuracy and reliability, it must undergo thorough calibration and validation. Key steps in this process include selecting relevant features (variables), choosing an appropriate modeling method (such as regression analysis, decision trees, neural networks, etc.), training the model with survey data, and subsequently testing its predictions against known outcomes. A thorough understanding of the data, expertise in data analysis and statistical modeling, along with a deep awareness of the complexities surrounding LGBTI rights, are essential for successfully completing this assignment.

Target variable: qc19 (support for changing gender on documents)

ASSIGMENT SUBMISSION GUIDELINES Teams are responsible for assembling a comprehensive package for submission. This package must include:

• Code: Complete and well-documented source code developed for the project. • Narrative Explanation: A detailed narrative of the work, not exceeding four pages (excluding references).

This narrative should articulate the reasoning behind strategic choices, describe the challenges encountered and how they were overcome, and present/discuss the main results. The completed package must be uploaded to the designated task on Aula Global.

### LIBRARY

```{r}
rm(list = ls())
library(haven)
library(writexl)
library(sjlabelled)
library(tidyverse)
library(corrplot)
library(dplyr)

```

### Data

```{r}
data <- read_dta("./ZA7575.dta")

```

```{r}

variable_labels <- get_label(data)

# Crear un data frame con los nombres de las variables y sus etiquetas
variable_dictionary <- tibble(Variable = names(variable_labels),
                              Label = variable_labels)
# Pasarlo a un excel
#write_xlsx(variable_dictionary, "variable_dictionary.xlsx")
```

## Cleaning the data

```{r}
summary(data$studyno2) # studyno1 and studyno2 simple identifier that has the same name # I would remove it
```

**I would remove this variables from the data set as they are a reference id for the survey as a hole and not relevant in our analysis.**

-   studyno1

-   studyno2

-   doi

-   version

-   edition

-   survey

-   weights, we can add them later for regression. (w1:w86,wex)

-   Comment Frederick: let's get rid of every variable from qa and qb we don't need them (they are on globalisation and trade or something)

-   d71_1:qb9_12

-   I kept the following variables

    -   QA5a: Question on globalisation

    -   QA6: Question on what will affect jobs in the coming years (immigration option might be interesting)

```{r}
data_cleaning_1 <- select(data, -c(studyno1, studyno2, doi, version, edition,survey,w1:w86,wex))
```

```{r}
data_cleaning_1 <- data_cleaning_1 %>%
  select(
         -c(
      p13be, p13ee, p13es, p13fi, p13lu, p13lv, p13mt, 
      cntry_de, eu6, eu9, eu10, eu12_1, eu12_2, eu_nms3, 
      eu15, eu_nms10, eu25, eu_ac2, eu_cc3, euroz13, 
      euronz13, eu_nms12, eu27, eu27b, eu_nms13, eu28, 
      euroz15, euronz15, euroz16, euronz16, euroz17, 
      eurnz17a, eurnz17b, euroz18, eurnz18a, eurnz18b, 
      eurnz18c, euroz19, euronz19, p2, p3r, p4, p5, d71_1:qa4b_8, qa5b_1:qa5b_13, qa7:qb9_12
    )
  )
```

The variables p2,p4,p3r,p4 and p5 where variable related to certain characteristics of the interview itself, we deemed them not relevant due to their context.

The p13's variables where the language the interview was conducted with.

The rest of the variables are related to the NATION GROUP, so we decided to take them out as we have other variables that seem to explain the same and be more relevant.

```{r}
data_cleaning_2 <- data_cleaning_1 %>% 
  select(serialid, everything())
```

#### Country

```{r}
# creating a variable for country name to be more organized
data_cleaning_2$country_name <- NA

data_cleaning_2$country_name[data_cleaning_2$q1_1 == 1] <- 'Bélgica'
data_cleaning_2$country_name[data_cleaning_2$q1_2 == 1] <- 'Dinamarca'
data_cleaning_2$country_name[data_cleaning_2$q1_3 == 1] <- 'Alemania'
data_cleaning_2$country_name[data_cleaning_2$q1_4 == 1] <- 'Grecia'
data_cleaning_2$country_name[data_cleaning_2$q1_5 == 1] <- 'España'
data_cleaning_2$country_name[data_cleaning_2$q1_6 == 1] <- 'Francia'
data_cleaning_2$country_name[data_cleaning_2$q1_7 == 1] <- 'Irlanda'
data_cleaning_2$country_name[data_cleaning_2$q1_8 == 1] <- 'Italia'
data_cleaning_2$country_name[data_cleaning_2$q1_9 == 1] <- 'Luxemburgo'
data_cleaning_2$country_name[data_cleaning_2$q1_10 == 1] <- 'Países Bajos'
data_cleaning_2$country_name[data_cleaning_2$q1_11 == 1] <- 'Portugal'
data_cleaning_2$country_name[data_cleaning_2$q1_12 == 1] <- 'Reino Unido'
data_cleaning_2$country_name[data_cleaning_2$q1_13 == 1] <- 'Austria'
data_cleaning_2$country_name[data_cleaning_2$q1_14 == 1] <- 'Suecia'
data_cleaning_2$country_name[data_cleaning_2$q1_15 == 1] <- 'Finlandia'
data_cleaning_2$country_name[data_cleaning_2$q1_16 == 1] <- 'República de Chipre'
data_cleaning_2$country_name[data_cleaning_2$q1_17 == 1] <- 'República Checa'
data_cleaning_2$country_name[data_cleaning_2$q1_18 == 1] <- 'Estonia'
data_cleaning_2$country_name[data_cleaning_2$q1_19 == 1] <- 'Hungría'
data_cleaning_2$country_name[data_cleaning_2$q1_20 == 1] <- 'Letonia'
data_cleaning_2$country_name[data_cleaning_2$q1_21 == 1] <- 'Lituania'
data_cleaning_2$country_name[data_cleaning_2$q1_22 == 1] <- 'Malta'
data_cleaning_2$country_name[data_cleaning_2$q1_23 == 1] <- 'Polonia'
data_cleaning_2$country_name[data_cleaning_2$q1_24 == 1] <- 'Eslovaquia'
data_cleaning_2$country_name[data_cleaning_2$q1_25 == 1] <- 'Eslovenia'
data_cleaning_2$country_name[data_cleaning_2$q1_26 == 1] <- 'Bulgaria'
data_cleaning_2$country_name[data_cleaning_2$q1_27 == 1] <- 'Rumanía'
data_cleaning_2$country_name[data_cleaning_2$q1_28 == 1] <- 'Croacia'
data_cleaning_2$country_name[data_cleaning_2$q1_29 == 1] <- 'Otros países'
data_cleaning_2$country_name[data_cleaning_2$q1_30 == 1] <- 'DK'  # no idea what this is

```

```{r}
data_cleaning_2 <- data_cleaning_2 %>% 
  select(serialid,country_name, everything())

# factor
data_cleaning_2$country_name <- factor(data_cleaning_2$country_name)
```

Removing q1_1 to q1_30

```{r}
data_cleaning_3 <- select(data_cleaning_2, -c(q1_1:q1_30))

```

#### Age

```{r}
data_cleaning_3 <- data_cleaning_3 %>%
  mutate(
    d11r1_recoded = factor(d11r1, 
                           labels = c("15 - 24", "25 - 39", "40 - 54", ">=55")),
    d11r2_recoded = factor(d11r2, 
                           labels = c("15 - 24", "25 - 34", "35 - 44", "45 - 54", "55 - 64", ">=65")),
    d11r3_recoded = factor(d11r3, 
                           labels = c("15 - 24", "25 - 34", "35 - 44", "45 - 54", "55 - 64", "65 - 74", ">=75"))
  )

```

```{r}
data_cleaning_4 <- select(data_cleaning_3, -c(d11r1,d11r2,d11r3))
```

Gender

```{r}
data_cleaning_4 <- data_cleaning_4 %>%
  mutate(
    gender = case_when(
      d10 == 1 ~ "male",
      d10 == 2 ~ "female"
    ),
    gender = factor(gender, levels = c("male", "female"))
  )

```

#### Dependent Variable (qc19) - values are 1 for yes 2 for no and 3 for don t know (DK)

```{r}
#making multinominal variable

data_cleaning_4$qc19_multinominal <- factor(data_cleaning_4$qc19, levels = c(1, 2, 3),labels = c("Yes", "No", "Don't know"))

class(data_cleaning_4$qc19_multinominal)
```

```{r}
data_cleaning_5 <- data_cleaning_4 %>% 
  select(serialid,qc19_multinominal,country_name,gender,d11, everything())
```

### Looking into the categorical variables.

```{r}
categorical_vars <- names(data_cleaning_5)[sapply(data_cleaning_5, function(x) is.factor(x) | is.character(x))]

# Print the names of categorical variables
print(categorical_vars)

```

```{r}
categorical_vars <- c("country_name", "gender","isocntry","d11r1_recoded", "d11r2_recoded", "d11r3_recoded") # i took out the variable nuts becuase it was giving warning and its just a sigla.

for(var in categorical_vars) {
  cat("Chi-square test for:", var, "\n")
  table <- table(data_cleaning_5[[var]], data_cleaning_5$qc19_multinominal)
  test <- chisq.test(table)
  print(test)
}

```

All the variables tested show a statistically significant association with your dependent variable.

-   "country_name", "gender","isocntry","d11r1_recoded", "d11r2_recoded", "d11r3_recoded"

### Looking into the continuous variables.

```{r}
# Getting all the numeric and integer variables in the dataset
continuous_vars <- names(data_cleaning_5)[sapply(data_cleaning_5, function(x) is.numeric(x) | is.integer(x))]
```

```{r}
library(parallel)
```

```{r}
# Define the function to perform the Kruskal-Wallis test
performTest <- function(var) {
  formula <- as.formula(paste(var, "~ qc19_multinominal"))
  testResult <- kruskal.test(formula, data = data_cleaning_5)
  return(list(variable = var, p.value = testResult$p.value))
}

# Detect the number of cores and set up a cluster
no_cores <- detectCores() - 1
cl <- makeCluster(no_cores)

# Export the necessary variables and functions to the cluster
clusterExport(cl, varlist = c("data_cleaning_5", "performTest"))

# Perform the tests in parallel
results <- parLapply(cl, continuous_vars, performTest)

# Stop the cluster
stopCluster(cl)
```

```{r}
# Convert the list of results into a data frame
results_df <- do.call(rbind, lapply(results, function(x) {
  data.frame(Variable = x$variable, PValue = x$p.value, stringsAsFactors = FALSE)
}))

# Order the results by p-value
results_df <- results_df[order(results_df$PValue), ]
```

#### Significant

```{r}
# Create a vector for significant variables (p-value <= 0.05)
significant_vars <- results_df$Variable[results_df$PValue <= 0.05]

# Create a vector for non-significant variables (p-value > 0.05)
non_significant_vars <- results_df$Variable[results_df$PValue > 0.05]

# Print or use the vectors as needed
print("Significant variables:")
print(significant_vars)



```

That's the code that helps subset the data set based on the significant variables.

```{r}
non_zero_vars <- non_zero_vars[-1] 

non_zero_vars

df_schools_final <- 
  df_schools_e |>  
  dplyr::select(all_of(non_zero_vars), n_schools, income_per_capita)
```

#### Not Significant

```{r}
print("Non-significant variables:")
print(non_significant_vars)
```

## First look at association

### Gender

Assumption from literature –\> men less supportive than women

```{r}
qc19labels <- c("Yes", "No", "Don't know")
names(qc19labels) <- c(1, 2, 3)


data_cleaning_5 |>
  mutate(d10 = as.factor(d10),
         qc19_n = as.numeric(qc19),
         qc19 = as.factor(qc19)) |> 
  group_by(d10) |> 
  mutate(gsumqc19 = sum(qc19_n)) |> 
  ungroup() |> 
  group_by(qc19, d10) |> 
  mutate(gshare19 = (sum(qc19_n)/gsumqc19)*100) |> 
  ungroup() |> 
  ggplot(aes(x = qc19_multinominal, y = gshare19, fill = d10))+
  geom_bar(stat = "identity", position = "dodge")+
  geom_text((aes(label = sprintf("%.1f%%", gshare19))), position = position_dodge(width = 0.9), vjust = -0.3, size = 3) +
  theme(legend.position = "bottom") +
  labs(title = "Do you think that transgender persons should be able to change\ntheir civil documents to match their inner gender identity?",
y = NULL,
x = NULL,
caption = "Source: Eurobarometer 91.4") +
  scale_fill_manual(labels = c("Men", "Women"), values = c("blue", "red")) + 
  guides(fill=guide_legend(title= ""))
```

### Binary conception of gender

predictor of support of US sample

operationalization using question 20 on if there should be a third gender option

Table

```{r}
data_cleaning_5$qc20_multinominal <- factor(data_cleaning_4$qc20, levels = c(1, 2, 3),labels = c("Yes", "No", "Don't know"))

library(gmodels)
CrossTable(data_cleaning_5$qc19_multinominal, data_cleaning_5$qc20_multinominal, 
           digits=2, 
           expected=F, 
           asresid=T, 
           chisq=TRUE, 
           prop.chisq=F, 
           format="SPSS")
```

Since the p-value is much smaller than the conventional significance level of 0.05, we reject the null hypothesis. This suggests that there is a significant association between the variables **`qc19`** and **`qc20`**.

Very high convergence of people against a third gender option and rejecting

88.29% of those against a third gender option also negate the option for transgender persons to change their gender in civil documents.

Differences in binary gender conception –\> country differences

country average against

##### Indicate that it's only the nos

```{r}
library(patchwork)
library(scales)

plot_binary_1 <-
  data_cleaning_5 |> 
  group_by(country_name) |> 
  summarise(share_no = mean(qc20 == 2, na.rm = TRUE)*100) |> 
  arrange(desc(share_no)) |> 
  mutate(country_name = factor(country_name, levels = country_name)) |>
  filter(country_name != "Otros países") |> 
ggplot(aes(x = country_name, y = share_no)) +
  geom_col(fill = "red") +
  labs(x = "",
       y = "") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        plot.margin = margin(0, 0, 0, 0))  +
  scale_y_continuous(labels = scales::percent_format(scale = 1)) +
  geom_text((aes(label = sprintf("%.1f%%", share_no))),vjust = -0.5, size = 2)  +
  annotate("text", x = 9.5, y = 70, 
           label = "Share of 'No' responses to qc19:\nDo you think that transgender persons should be able to change\ntheir civil documents to match their inner gender identity?",
           hjust = 0, vjust = 0.5, size = 3, color = "black") +
  geom_rect(aes(xmin = 9.3, xmax = 24.3, 
                ymin = 62, ymax = 77),
                fill = "transparent", color = "black", linewidth = 1)

plot_binary_2 <- 
  data_cleaning_5 |> 
  group_by(country_name) |> 
  summarise(share_no = mean(qc19 == 2, na.rm = TRUE)*100) |> 
  arrange(desc(share_no)) |> 
  mutate(country_name = factor(country_name, levels = country_name)) |>
  filter(country_name != "Otros países") |> 
ggplot(aes(x = country_name, y = share_no)) +
  geom_col(fill = "red") +
  labs(x = "",
       y = "") +
  theme_minimal()+ 
  theme(axis.text.x = element_text(angle = 90, hjust= 0),
        plot.margin = margin(-10, 0, 0, 0)) +
  scale_x_discrete(position = "top") +
  scale_y_continuous(labels = scales::percent_format(scale = 1)) +
  geom_text((aes(label = sprintf("%.1f%%", share_no))), vjust = -0.5, size = 2)  +
  annotate("text", x = 10, y = 65, 
           label = "Share of 'No' responses to qc20:\nDo you believe that official documents, like passports and birth\ncertificates, should have a third option, such as X or O (other)\nbeside male (M) and female (F)for those persons who do not\nidentify as female and male?",
           hjust = 0, vjust = 0.5, size = 3, color = "black") +
  geom_rect(aes(xmin = 9.8, xmax = 24.6, 
                ymin = 53, ymax = 76),
                fill = "transparent", color = "black", linewidth = 1)

plot_binary_2
```

```{r}
#| echo: false
#| layout-ncol: 1

plot_binary_1
plot_binary_2
```

## CORRELATION BETWEEN VARIABLES

```{r}
complete_data <- data_cleaning_5 |> 
  select(-non_significant_vars) |> 
  select(-c(qa1:qb9_12)) |> 
  mutate_if(is.character, as.numeric)

target_columns <- c("qc19", "qc20")

# Convert target_columns to numeric
complete_data[target_columns] <- lapply(complete_data[target_columns], as.numeric)

# Filter out rows with missing values in target columns
complete_data <- complete_data[complete.cases(complete_data[target_columns]), ]



#defining columns that will work for the correlation matrix
numeric_cols <- complete_data[numeric_columns]

# Determine the number of columns in complete_data
num_cols <- ncol(numeric_cols)

# Calculate the number of columns in each subset (assuming you want approximately equal splits)
subset_size <- ceiling(num_cols / 6)

# Split complete_data into three subsets
subset_1 <- numeric_cols[, 1:subset_size]
subset_2 <- numeric_cols[, (subset_size + 1):(2 * subset_size)]
subset_3 <- numeric_cols[, (2 * subset_size + 1):(3 * subset_size)]
subset_4 <- numeric_cols[, (3 * subset_size + 1):(4 * subset_size)]
subset_5 <- numeric_cols[, (4 * subset_size + 1):(5 * subset_size)]
subset_6 <- numeric_cols[, (5 * subset_size + 1):num_cols]

#1
cor_matrix1 <- cor(complete_data[target_columns], subset_1, use = "pairwise.complete.obs")
corr1 <- corrplot(cor_matrix1, method = "circle", tl.col = "black", tl.srt = 45)

#2
cor_matrix2 <- cor(complete_data[target_columns], subset_2, use = "pairwise.complete.obs")
corr2 <- corrplot(cor_matrix2, method = "circle", tl.col = "black", tl.srt = 45)

#3
cor_matrix3 <- cor(complete_data[target_columns], subset_3, use = "pairwise.complete.obs")
corr3 <- corrplot(cor_matrix3, method = "circle", tl.col = "black", tl.srt = 45)

#4
cor_matrix4 <- cor(complete_data[target_columns], subset_4, use = "pairwise.complete.obs")
corr4 <- corrplot(cor_matrix4, method = "circle", tl.col = "black", tl.srt = 45)

#5
cor_matrix5 <- cor(complete_data[target_columns], subset_5, use = "pairwise.complete.obs")
corr5 <- corrplot(cor_matrix5, method = "circle", tl.col = "black", tl.srt = 45)

#6
cor_matrix6 <- cor(complete_data[target_columns], subset_6, use = "pairwise.complete.obs")
corr6 <- corrplot(cor_matrix6, method = "circle", tl.col = "black", tl.srt = 45)
```

COUNTRY LEVEL VARIABLES (EXTRA)

```{r}
library(haven)
data_extra_by_Country <- read_dta("Data/Extra Data.dta")
all_na_columns <- sapply(data_extra_by_Country, function(x) all(is.na(x)))

# There are columns all NA because I filtered in stata for the year and for each country certain variables that where interesting

columns_to_remove <- names(data_extra_by_Country)[all_na_columns]

# remove the columns
data_extra_by_Country <- data_extra_by_Country[, !all_na_columns]

# dataframe of all the variables for 2019 related to legal or political views of most of the countries in the world
names(data_extra_by_Country)


# Save the dataframe as a CSV file
# write.csv(data_extra_by_Country, "Data/data_extra_by_Country.csv", row.names = FALSE)

```

```{r}
# merged_df <- merge(data_cleaning_5, data_extra_by_Country, by = "country_name", all.x = TRUE)
# hay un error que tengo que ver
```
